import { isPlainObject, isFullString, isFullArray } from 'is-what';
import { merge } from 'merge-anything';
import { parse } from 'vue-docgen-api';
import logSymbols from 'log-symbols';
import chalk from 'chalk';
import { getProp } from 'path-to-prop';
import * as fs from 'fs';
import * as path from 'path';
import { resolve } from 'path';
import { readdir } from 'fs/promises';
import { kebabCase, pascalCase } from 'case-anything';

/**
 * extract alias file config absolute path and nested property by dot
 * @param {string} alias
 */
function extractAliasPath(alias) {
    const [configFilePath, ...aliasNested] = alias.replace(/^#|#$/g, '').split('#');
    const aliasAbsolutePath = path.isAbsolute(configFilePath)
        ? configFilePath
        : path.resolve(process.cwd(), configFilePath);
    if (!fs.existsSync(aliasAbsolutePath)) {
        throw new Error(`[vue-intellisense] ${aliasAbsolutePath} is not found`);
    }
    // not nested alias
    if (aliasNested.length === 0) {
        return { aliasAbsolutePath, nestedPropsByDot: '' };
    }
    // example: resolve.alias
    const nestedPropsByDot = aliasNested.join('.');
    return { aliasAbsolutePath, nestedPropsByDot };
}
/**
 *
 * @param aliasAbsolutePath
 * @param nestedPropsByDot like: resolve.alias
 * @returns
 */
async function getAliasFromFilePath(aliasAbsolutePath, nestedPropsByDot) {
    const configFile = await import(aliasAbsolutePath);
    if (!nestedPropsByDot)
        return configFile;
    return getProp(configFile, nestedPropsByDot) || null;
}
async function readAndParseAlias(rawAliases) {
    let parsedAliase = {};
    // contain merged aliase of all file config
    for (const rawAlias of rawAliases) {
        const { aliasAbsolutePath, nestedPropsByDot } = extractAliasPath(rawAlias);
        const extractedAliasObj = await getAliasFromFilePath(aliasAbsolutePath, nestedPropsByDot);
        if (!extractedAliasObj) {
            throw new Error(`[vue-intellisense] ${rawAlias} is not contain alias config object`);
        }
        if (isPlainObject(extractedAliasObj))
            parsedAliase = merge(parsedAliase, extractedAliasObj);
    }
    return parsedAliase;
}
/**
 *  Make console.warn throw, so that we can check warning aliase config not correct
 */
function handleWarningMissingAlias() {
    const warn = console.warn;
    console.warn = function (message, ...args) {
        warn.apply(console, args);
        if (['Neither', 'nor', 'or', 'could be found in'].every((msg) => message.includes(msg))) {
            console.log(`${logSymbols.error} ${chalk.bold('[vue-intellisense] Your aliases config is missing or wrong')}!`);
        }
    };
}

async function listFilesNonRecursive(folderPath) {
    const dirents = await readdir(folderPath, { withFileTypes: true });
    const files = await Promise.all(dirents.flatMap((dirent) => {
        const res = resolve(folderPath, dirent.name);
        return dirent.isDirectory() ? [] : res;
    }));
    const allFiles = Array.prototype.concat(...files);
    return allFiles;
}
async function listFilesRecursively(folderPath) {
    const dirents = await readdir(folderPath, { withFileTypes: true });
    const files = await Promise.all(dirents.map((dirent) => {
        const res = resolve(folderPath, dirent.name);
        return dirent.isDirectory() ? listFilesRecursively(res) : [res];
    }));
    const allFiles = Array.prototype.concat(...files);
    return allFiles;
}
/**
 * @param {string} folderPath "resources/foo/goo"
 * @param {{
 *   regexFilter?: RegExp,
 *   resolvePaths?: boolean,
 *   recursive?: boolean,
 * }} options
 * regexFilter: RegExp - eg. /\.txt/ for only .txt files
 *
 * resolvePaths: boolean - when true it will return the _full_ path from the file system's root. If false (default) it will return the relativePath based on the initial directory path passed
 *
 * recursive: boolean - when true it will return ALL paths recursively. If false (default) it will only return the paths from the folder
 * @return {Promise<string[]>}
 */
async function listFiles(folderPath, options) {
    const { regexFilter, resolvePaths, recursive } = options || {};
    if (folderPath.endsWith('/'))
        folderPath = folderPath.slice(0, -1);
    const parentDirFullPath = resolve(folderPath).split(folderPath)[0];
    let allFiles = recursive
        ? await listFilesRecursively(folderPath)
        : await listFilesNonRecursive(folderPath);
    if (regexFilter === undefined && !resolvePaths)
        return allFiles;
    return allFiles.flatMap((filePath) => {
        if (!resolvePaths)
            filePath = filePath.replace(parentDirFullPath, '');
        if (regexFilter === undefined)
            return filePath;
        return filePath.match(regexFilter) ? filePath : [];
    });
}

function vueDocgenToVetur(vueDocgen, veturFile) {
    const componentName = vueDocgen.displayName;
    if (!isFullString(componentName)) {
        throw new Error('[vue-intellisense] Component is missing a "name" property.');
    }
    const componentNameKebab = kebabCase(componentName);
    const componentNamePascal = pascalCase(componentName);
    if (veturFile === 'attributes') {
        const props = vueDocgen.props || [];
        return props.reduce((carry, vueDocgenProp) => {
            const { name, description, type: _type, values = [], tags: customTags = {} } = vueDocgenProp;
            const attributeName = `${componentNameKebab}/${name}`;
            const attributePascal = `${componentNamePascal}/${name}`;
            const t = _type?.name || '';
            const type = t.endsWith('[]') ? 'array' : t.replace('func', 'function');
            // get the "options" from string literals
            const _typeTags = customTags.type || [];
            const typeTags = _typeTags.map((t) => t.type.name);
            const valuesCalculated = values.length
                ? values
                : typeTags.length
                    ? typeTags[0]
                        .split('|')
                        .map((t) => t.trim())
                        .filter((t) => t[0] === `'` && t[t.length - 1] === `'`)
                        .map((t) => t.slice(1, -1))
                    : [];
            const options = valuesCalculated.length ? { options: valuesCalculated } : {};
            return {
                ...carry,
                [attributeName]: { type, description, ...options },
                [attributePascal]: { type, description, ...options },
            };
        }, {});
    }
    if (veturFile === 'tags') {
        const props = vueDocgen.props || [];
        const attributes = props.map(({ name }) => name);
        return {
            [componentNameKebab]: { attributes, description: vueDocgen.description || '' },
            [componentNamePascal]: { attributes, description: vueDocgen.description || '' },
        };
    }
    throw new Error('[vue-intellisense] wrong args');
}

handleWarningMissingAlias();
async function vueFilePathToVeturJsonData(vueFilePath, veturFile, options = {}) {
    const { alias } = options;
    const docGenOptions = isPlainObject(alias) ? { alias } : undefined;
    const vueDocgen = await parse(vueFilePath, docGenOptions);
    if (!isPlainObject(vueDocgen))
        return {};
    const jsonData = vueDocgenToVetur(vueDocgen, veturFile);
    return jsonData;
}
async function vueFilePathsToVeturJsonData(inputPaths, veturFile, options) {
    const objects = await Promise.all(inputPaths.map((path) => vueFilePathToVeturJsonData(path, veturFile, options)));
    if (!objects.length)
        throw '[vue-intellisense] missing <input paths>';
    return merge(objects[0], ...objects.slice(1));
}
async function writeVeturFiles(outputPath, attributes, tags) {
    const _out = outputPath.endsWith('/') ? outputPath : outputPath + '/';
    fs.mkdirSync(_out, { recursive: true });
    fs.writeFileSync(_out + 'attributes.json', JSON.stringify(attributes, undefined, 2));
    fs.writeFileSync(_out + 'tags.json', JSON.stringify(tags, undefined, 2));
}
async function generateVeturFiles(inputPath, outputPath, options) {
    const { recursive, alias } = options || {};
    const inputIsFile = ['.vue', '.jsx', '.tsx'].some((fileType) => inputPath.endsWith(fileType));
    const allFiles = inputIsFile
        ? [inputPath]
        : await listFiles(inputPath, {
            regexFilter: /\.vue|\.jsx|\.tsx/,
            recursive,
            resolvePaths: true,
        });
    let parsedAliase = alias;
    if (isFullArray(alias))
        parsedAliase = await readAndParseAlias(alias);
    const attributes = await vueFilePathsToVeturJsonData(allFiles, 'attributes', {
        ...options,
        alias: parsedAliase,
    });
    const tags = await vueFilePathsToVeturJsonData(allFiles, 'tags', {
        ...options,
        alias: parsedAliase,
    });
    await writeVeturFiles(outputPath, attributes, tags);
}

export { generateVeturFiles, vueFilePathToVeturJsonData };
