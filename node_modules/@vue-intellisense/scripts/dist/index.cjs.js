'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isWhat = require('is-what');
var mergeAnything = require('merge-anything');
var vueDocgenApi = require('vue-docgen-api');
var logSymbols = require('log-symbols');
var chalk = require('chalk');
var pathToProp = require('path-to-prop');
var fs = require('fs');
var path = require('path');
var promises = require('fs/promises');
var caseAnything = require('case-anything');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var logSymbols__default = /*#__PURE__*/_interopDefaultLegacy(logSymbols);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);

/**
 * extract alias file config absolute path and nested property by dot
 * @param {string} alias
 */
function extractAliasPath(alias) {
    const [configFilePath, ...aliasNested] = alias.replace(/^#|#$/g, '').split('#');
    const aliasAbsolutePath = path__namespace.isAbsolute(configFilePath)
        ? configFilePath
        : path__namespace.resolve(process.cwd(), configFilePath);
    if (!fs__namespace.existsSync(aliasAbsolutePath)) {
        throw new Error(`[vue-intellisense] ${aliasAbsolutePath} is not found`);
    }
    // not nested alias
    if (aliasNested.length === 0) {
        return { aliasAbsolutePath, nestedPropsByDot: '' };
    }
    // example: resolve.alias
    const nestedPropsByDot = aliasNested.join('.');
    return { aliasAbsolutePath, nestedPropsByDot };
}
/**
 *
 * @param aliasAbsolutePath
 * @param nestedPropsByDot like: resolve.alias
 * @returns
 */
async function getAliasFromFilePath(aliasAbsolutePath, nestedPropsByDot) {
    const configFile = await (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(aliasAbsolutePath);
    if (!nestedPropsByDot)
        return configFile;
    return pathToProp.getProp(configFile, nestedPropsByDot) || null;
}
async function readAndParseAlias(rawAliases) {
    let parsedAliase = {};
    // contain merged aliase of all file config
    for (const rawAlias of rawAliases) {
        const { aliasAbsolutePath, nestedPropsByDot } = extractAliasPath(rawAlias);
        const extractedAliasObj = await getAliasFromFilePath(aliasAbsolutePath, nestedPropsByDot);
        if (!extractedAliasObj) {
            throw new Error(`[vue-intellisense] ${rawAlias} is not contain alias config object`);
        }
        if (isWhat.isPlainObject(extractedAliasObj))
            parsedAliase = mergeAnything.merge(parsedAliase, extractedAliasObj);
    }
    return parsedAliase;
}
/**
 *  Make console.warn throw, so that we can check warning aliase config not correct
 */
function handleWarningMissingAlias() {
    const warn = console.warn;
    console.warn = function (message, ...args) {
        warn.apply(console, args);
        if (['Neither', 'nor', 'or', 'could be found in'].every((msg) => message.includes(msg))) {
            console.log(`${logSymbols__default["default"].error} ${chalk__default["default"].bold('[vue-intellisense] Your aliases config is missing or wrong')}!`);
        }
    };
}

async function listFilesNonRecursive(folderPath) {
    const dirents = await promises.readdir(folderPath, { withFileTypes: true });
    const files = await Promise.all(dirents.flatMap((dirent) => {
        const res = path.resolve(folderPath, dirent.name);
        return dirent.isDirectory() ? [] : res;
    }));
    const allFiles = Array.prototype.concat(...files);
    return allFiles;
}
async function listFilesRecursively(folderPath) {
    const dirents = await promises.readdir(folderPath, { withFileTypes: true });
    const files = await Promise.all(dirents.map((dirent) => {
        const res = path.resolve(folderPath, dirent.name);
        return dirent.isDirectory() ? listFilesRecursively(res) : [res];
    }));
    const allFiles = Array.prototype.concat(...files);
    return allFiles;
}
/**
 * @param {string} folderPath "resources/foo/goo"
 * @param {{
 *   regexFilter?: RegExp,
 *   resolvePaths?: boolean,
 *   recursive?: boolean,
 * }} options
 * regexFilter: RegExp - eg. /\.txt/ for only .txt files
 *
 * resolvePaths: boolean - when true it will return the _full_ path from the file system's root. If false (default) it will return the relativePath based on the initial directory path passed
 *
 * recursive: boolean - when true it will return ALL paths recursively. If false (default) it will only return the paths from the folder
 * @return {Promise<string[]>}
 */
async function listFiles(folderPath, options) {
    const { regexFilter, resolvePaths, recursive } = options || {};
    if (folderPath.endsWith('/'))
        folderPath = folderPath.slice(0, -1);
    const parentDirFullPath = path.resolve(folderPath).split(folderPath)[0];
    let allFiles = recursive
        ? await listFilesRecursively(folderPath)
        : await listFilesNonRecursive(folderPath);
    if (regexFilter === undefined && !resolvePaths)
        return allFiles;
    return allFiles.flatMap((filePath) => {
        if (!resolvePaths)
            filePath = filePath.replace(parentDirFullPath, '');
        if (regexFilter === undefined)
            return filePath;
        return filePath.match(regexFilter) ? filePath : [];
    });
}

function vueDocgenToVetur(vueDocgen, veturFile) {
    const componentName = vueDocgen.displayName;
    if (!isWhat.isFullString(componentName)) {
        throw new Error('[vue-intellisense] Component is missing a "name" property.');
    }
    const componentNameKebab = caseAnything.kebabCase(componentName);
    const componentNamePascal = caseAnything.pascalCase(componentName);
    if (veturFile === 'attributes') {
        const props = vueDocgen.props || [];
        return props.reduce((carry, vueDocgenProp) => {
            const { name, description, type: _type, values = [], tags: customTags = {} } = vueDocgenProp;
            const attributeName = `${componentNameKebab}/${name}`;
            const attributePascal = `${componentNamePascal}/${name}`;
            const t = _type?.name || '';
            const type = t.endsWith('[]') ? 'array' : t.replace('func', 'function');
            // get the "options" from string literals
            const _typeTags = customTags.type || [];
            const typeTags = _typeTags.map((t) => t.type.name);
            const valuesCalculated = values.length
                ? values
                : typeTags.length
                    ? typeTags[0]
                        .split('|')
                        .map((t) => t.trim())
                        .filter((t) => t[0] === `'` && t[t.length - 1] === `'`)
                        .map((t) => t.slice(1, -1))
                    : [];
            const options = valuesCalculated.length ? { options: valuesCalculated } : {};
            return {
                ...carry,
                [attributeName]: { type, description, ...options },
                [attributePascal]: { type, description, ...options },
            };
        }, {});
    }
    if (veturFile === 'tags') {
        const props = vueDocgen.props || [];
        const attributes = props.map(({ name }) => name);
        return {
            [componentNameKebab]: { attributes, description: vueDocgen.description || '' },
            [componentNamePascal]: { attributes, description: vueDocgen.description || '' },
        };
    }
    throw new Error('[vue-intellisense] wrong args');
}

handleWarningMissingAlias();
async function vueFilePathToVeturJsonData(vueFilePath, veturFile, options = {}) {
    const { alias } = options;
    const docGenOptions = isWhat.isPlainObject(alias) ? { alias } : undefined;
    const vueDocgen = await vueDocgenApi.parse(vueFilePath, docGenOptions);
    if (!isWhat.isPlainObject(vueDocgen))
        return {};
    const jsonData = vueDocgenToVetur(vueDocgen, veturFile);
    return jsonData;
}
async function vueFilePathsToVeturJsonData(inputPaths, veturFile, options) {
    const objects = await Promise.all(inputPaths.map((path) => vueFilePathToVeturJsonData(path, veturFile, options)));
    if (!objects.length)
        throw '[vue-intellisense] missing <input paths>';
    return mergeAnything.merge(objects[0], ...objects.slice(1));
}
async function writeVeturFiles(outputPath, attributes, tags) {
    const _out = outputPath.endsWith('/') ? outputPath : outputPath + '/';
    fs__namespace.mkdirSync(_out, { recursive: true });
    fs__namespace.writeFileSync(_out + 'attributes.json', JSON.stringify(attributes, undefined, 2));
    fs__namespace.writeFileSync(_out + 'tags.json', JSON.stringify(tags, undefined, 2));
}
async function generateVeturFiles(inputPath, outputPath, options) {
    const { recursive, alias } = options || {};
    const inputIsFile = ['.vue', '.jsx', '.tsx'].some((fileType) => inputPath.endsWith(fileType));
    const allFiles = inputIsFile
        ? [inputPath]
        : await listFiles(inputPath, {
            regexFilter: /\.vue|\.jsx|\.tsx/,
            recursive,
            resolvePaths: true,
        });
    let parsedAliase = alias;
    if (isWhat.isFullArray(alias))
        parsedAliase = await readAndParseAlias(alias);
    const attributes = await vueFilePathsToVeturJsonData(allFiles, 'attributes', {
        ...options,
        alias: parsedAliase,
    });
    const tags = await vueFilePathsToVeturJsonData(allFiles, 'tags', {
        ...options,
        alias: parsedAliase,
    });
    await writeVeturFiles(outputPath, attributes, tags);
}

exports.generateVeturFiles = generateVeturFiles;
exports.vueFilePathToVeturJsonData = vueFilePathToVeturJsonData;
